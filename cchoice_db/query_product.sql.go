// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query_product.sql

package cchoice_db

import (
	"context"
	"database/sql"
	"time"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO tbl_product (
	serial,
	name,
	description,
	brand_id,
	status,
	product_specs_id,
	unit_price_without_vat,
	unit_price_with_vat,
	unit_price_without_vat_currency,
	unit_price_with_vat_currency,
	created_at,
	updated_at,
	deleted_at
) VALUES (
	?, ?, ?, ?,
	?, ?, ?, ?,
	?, ?, ?, ?,
	?
) RETURNING id, serial, name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (TblProduct, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Serial,
		arg.Name,
		arg.Description,
		arg.BrandID,
		arg.Status,
		arg.ProductSpecsID,
		arg.UnitPriceWithoutVat,
		arg.UnitPriceWithVat,
		arg.UnitPriceWithoutVatCurrency,
		arg.UnitPriceWithVatCurrency,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	var i TblProduct
	err := row.Scan(
		&i.ID,
		&i.Serial,
		&i.Name,
		&i.Description,
		&i.BrandID,
		&i.Status,
		&i.ProductSpecsID,
		&i.UnitPriceWithoutVat,
		&i.UnitPriceWithVat,
		&i.UnitPriceWithoutVatCurrency,
		&i.UnitPriceWithVatCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT
	tbl_product.id, serial, tbl_product.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_product.created_at, tbl_product.updated_at, tbl_product.deleted_at, tbl_product_category.id, product_id, category, subcategory, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, tbl_brand.id, tbl_brand.name, tbl_brand.created_at, tbl_brand.updated_at, tbl_brand.deleted_at,
	tbl_brand.name AS brand_name
FROM tbl_product
INNER JOIN tbl_product_category ON tbl_product.id = tbl_product_category.product_id
INNER JOIN tbl_product_specs ON tbl_product.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brand ON tbl_brand.id = tbl_product.brand_id
WHERE tbl_product.id = ?
LIMIT 1
`

type GetProductByIDRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	ProductID                   int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductByID(ctx context.Context, id int64) (GetProductByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.Serial,
		&i.Name,
		&i.Description,
		&i.BrandID,
		&i.Status,
		&i.ProductSpecsID,
		&i.UnitPriceWithoutVat,
		&i.UnitPriceWithVat,
		&i.UnitPriceWithoutVatCurrency,
		&i.UnitPriceWithVatCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ID_2,
		&i.ProductID,
		&i.Category,
		&i.Subcategory,
		&i.ID_3,
		&i.Colours,
		&i.Sizes,
		&i.Segmentation,
		&i.PartNumber,
		&i.Power,
		&i.Capacity,
		&i.ScopeOfSupply,
		&i.ID_4,
		&i.Name_2,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.DeletedAt_2,
		&i.BrandName,
	)
	return i, err
}

const getProductBySerial = `-- name: GetProductBySerial :one
SELECT
	tbl_product.id, serial, tbl_product.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_product.created_at, tbl_product.updated_at, tbl_product.deleted_at, tbl_product_category.id, product_id, category, subcategory, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, tbl_brand.id, tbl_brand.name, tbl_brand.created_at, tbl_brand.updated_at, tbl_brand.deleted_at,
	tbl_brand.name AS brand_name
FROM tbl_product
INNER JOIN tbl_product_category ON tbl_product.id = tbl_product_category.product_id
INNER JOIN tbl_product_specs ON tbl_product.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brand ON tbl_brand.id = tbl_product.brand_id
WHERE tbl_product.serial = ?
LIMIT 1
`

type GetProductBySerialRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	ProductID                   int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductBySerial(ctx context.Context, serial string) (GetProductBySerialRow, error) {
	row := q.db.QueryRowContext(ctx, getProductBySerial, serial)
	var i GetProductBySerialRow
	err := row.Scan(
		&i.ID,
		&i.Serial,
		&i.Name,
		&i.Description,
		&i.BrandID,
		&i.Status,
		&i.ProductSpecsID,
		&i.UnitPriceWithoutVat,
		&i.UnitPriceWithVat,
		&i.UnitPriceWithoutVatCurrency,
		&i.UnitPriceWithVatCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ID_2,
		&i.ProductID,
		&i.Category,
		&i.Subcategory,
		&i.ID_3,
		&i.Colours,
		&i.Sizes,
		&i.Segmentation,
		&i.PartNumber,
		&i.Power,
		&i.Capacity,
		&i.ScopeOfSupply,
		&i.ID_4,
		&i.Name_2,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.DeletedAt_2,
		&i.BrandName,
	)
	return i, err
}

const getProductIDBySerial = `-- name: GetProductIDBySerial :one
;

SELECT id
FROM tbl_product
WHERE tbl_product.serial = ?
LIMIT 1
`

func (q *Queries) GetProductIDBySerial(ctx context.Context, serial string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getProductIDBySerial, serial)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getProducts = `-- name: GetProducts :many
SELECT
	tbl_product.id, serial, tbl_product.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_product.created_at, tbl_product.updated_at, tbl_product.deleted_at, tbl_product_category.id, product_id, category, subcategory, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, tbl_brand.id, tbl_brand.name, tbl_brand.created_at, tbl_brand.updated_at, tbl_brand.deleted_at,
	tbl_brand.name AS brand_name
FROM tbl_product
INNER JOIN tbl_product_category ON tbl_product.id = tbl_product_category.product_id
INNER JOIN tbl_product_specs ON tbl_product.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brand ON tbl_brand.id = tbl_product.brand_id
ORDER BY created_at DESC
`

type GetProductsRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	ProductID                   int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProducts(ctx context.Context) ([]GetProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsRow
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.ProductID,
			&i.Category,
			&i.Subcategory,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByFilter = `-- name: GetProductsByFilter :many
SELECT
	tbl_product.id, serial, tbl_product.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_product.created_at, tbl_product.updated_at, tbl_product.deleted_at, tbl_product_category.id, product_id, category, subcategory, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, tbl_brand.id, tbl_brand.name, tbl_brand.created_at, tbl_brand.updated_at, tbl_brand.deleted_at,
	tbl_brand.name AS brand_name
FROM tbl_product
INNER JOIN tbl_product_category ON tbl_product.id = tbl_product_category.product_id
INNER JOIN tbl_product_specs ON tbl_product.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brand ON tbl_brand.id = tbl_product.brand_id
WHERE
	(tbl_product.status = ?1 OR ?1 IS NULL) OR
	(tbl_brand.name = ?2 OR ?2 IS NULL)
ORDER BY tbl_product.updated_at DESC
`

type GetProductsByFilterParams struct {
	Status string
	Brand  string
}

type GetProductsByFilterRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	ProductID                   int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsByFilter(ctx context.Context, arg GetProductsByFilterParams) ([]GetProductsByFilterRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByFilter, arg.Status, arg.Brand)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByFilterRow
	for rows.Next() {
		var i GetProductsByFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.ProductID,
			&i.Category,
			&i.Subcategory,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByStatus = `-- name: GetProductsByStatus :many
SELECT
	tbl_product.id, serial, tbl_product.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_product.created_at, tbl_product.updated_at, tbl_product.deleted_at, tbl_product_category.id, product_id, category, subcategory, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, tbl_brand.id, tbl_brand.name, tbl_brand.created_at, tbl_brand.updated_at, tbl_brand.deleted_at,
	tbl_brand.name AS brand_name
FROM tbl_product
INNER JOIN tbl_product_category ON tbl_product.id = tbl_product_category.product_id
INNER JOIN tbl_product_specs ON tbl_product.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brand ON tbl_brand.id = tbl_product.brand_id
WHERE tbl_product.status = ?
ORDER BY created_at DESC
`

type GetProductsByStatusRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	ProductID                   int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsByStatus(ctx context.Context, status string) ([]GetProductsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByStatusRow
	for rows.Next() {
		var i GetProductsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.ProductID,
			&i.Category,
			&i.Subcategory,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByStatusSortByCreationDateAsc = `-- name: GetProductsByStatusSortByCreationDateAsc :many
SELECT
	tbl_product.id, serial, tbl_product.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_product.created_at, tbl_product.updated_at, tbl_product.deleted_at, tbl_product_category.id, product_id, category, subcategory, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, tbl_brand.id, tbl_brand.name, tbl_brand.created_at, tbl_brand.updated_at, tbl_brand.deleted_at,
	tbl_brand.name AS brand_name
FROM tbl_product
INNER JOIN tbl_product_category ON tbl_product.id = tbl_product_category.product_id
INNER JOIN tbl_product_specs ON tbl_product.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brand ON tbl_brand.id = tbl_product.brand_id
WHERE tbl_product.status = ?
ORDER BY tbl_product.created_at ASC
`

type GetProductsByStatusSortByCreationDateAscRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	ProductID                   int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsByStatusSortByCreationDateAsc(ctx context.Context, status string) ([]GetProductsByStatusSortByCreationDateAscRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByStatusSortByCreationDateAsc, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByStatusSortByCreationDateAscRow
	for rows.Next() {
		var i GetProductsByStatusSortByCreationDateAscRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.ProductID,
			&i.Category,
			&i.Subcategory,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByStatusSortByCreationDateDesc = `-- name: GetProductsByStatusSortByCreationDateDesc :many
SELECT
	tbl_product.id, serial, tbl_product.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_product.created_at, tbl_product.updated_at, tbl_product.deleted_at, tbl_product_category.id, product_id, category, subcategory, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, tbl_brand.id, tbl_brand.name, tbl_brand.created_at, tbl_brand.updated_at, tbl_brand.deleted_at,
	tbl_brand.name AS brand_name
FROM tbl_product
INNER JOIN tbl_product_category ON tbl_product.id = tbl_product_category.product_id
INNER JOIN tbl_product_specs ON tbl_product.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brand ON tbl_brand.id = tbl_product.brand_id
WHERE tbl_product.status = ?
ORDER BY tbl_product.created_at DESC
`

type GetProductsByStatusSortByCreationDateDescRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	ProductID                   int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsByStatusSortByCreationDateDesc(ctx context.Context, status string) ([]GetProductsByStatusSortByCreationDateDescRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByStatusSortByCreationDateDesc, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByStatusSortByCreationDateDescRow
	for rows.Next() {
		var i GetProductsByStatusSortByCreationDateDescRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.ProductID,
			&i.Category,
			&i.Subcategory,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByStatusSortByNameAsc = `-- name: GetProductsByStatusSortByNameAsc :many
SELECT
	tbl_product.id, serial, tbl_product.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_product.created_at, tbl_product.updated_at, tbl_product.deleted_at, tbl_product_category.id, product_id, category, subcategory, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, tbl_brand.id, tbl_brand.name, tbl_brand.created_at, tbl_brand.updated_at, tbl_brand.deleted_at,
	tbl_brand.name AS brand_name
FROM tbl_product
INNER JOIN tbl_product_category ON tbl_product.id = tbl_product_category.product_id
INNER JOIN tbl_product_specs ON tbl_product.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brand ON tbl_brand.id = tbl_product.brand_id
WHERE tbl_product.status = ?
ORDER BY LOWER(tbl_product.name) ASC
`

type GetProductsByStatusSortByNameAscRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	ProductID                   int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsByStatusSortByNameAsc(ctx context.Context, status string) ([]GetProductsByStatusSortByNameAscRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByStatusSortByNameAsc, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByStatusSortByNameAscRow
	for rows.Next() {
		var i GetProductsByStatusSortByNameAscRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.ProductID,
			&i.Category,
			&i.Subcategory,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByStatusSortByNameDesc = `-- name: GetProductsByStatusSortByNameDesc :many
SELECT
	tbl_product.id, serial, tbl_product.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_product.created_at, tbl_product.updated_at, tbl_product.deleted_at, tbl_product_category.id, product_id, category, subcategory, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, tbl_brand.id, tbl_brand.name, tbl_brand.created_at, tbl_brand.updated_at, tbl_brand.deleted_at,
	tbl_brand.name AS brand_name
FROM tbl_product
INNER JOIN tbl_product_category ON tbl_product.id = tbl_product_category.product_id
INNER JOIN tbl_product_specs ON tbl_product.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brand ON tbl_brand.id = tbl_product.brand_id
WHERE tbl_product.status = ?
ORDER BY LOWER(tbl_product.name) DESC
`

type GetProductsByStatusSortByNameDescRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	ProductID                   int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsByStatusSortByNameDesc(ctx context.Context, status string) ([]GetProductsByStatusSortByNameDescRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByStatusSortByNameDesc, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByStatusSortByNameDescRow
	for rows.Next() {
		var i GetProductsByStatusSortByNameDescRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.ProductID,
			&i.Category,
			&i.Subcategory,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsListing = `-- name: GetProductsListing :many
SELECT
	tbl_product.id,
	tbl_product.name,
	tbl_product.description,
	tbl_product.unit_price_with_vat,
	tbl_product.unit_price_with_vat_currency,
	tbl_brand.name AS brand_name
FROM tbl_product
INNER JOIN tbl_brand ON tbl_brand.id = tbl_product.brand_id
ORDER BY tbl_product.created_at DESC
LIMIT ?
`

type GetProductsListingRow struct {
	ID                       int64
	Name                     string
	Description              sql.NullString
	UnitPriceWithVat         int64
	UnitPriceWithVatCurrency string
	BrandName                string
}

func (q *Queries) GetProductsListing(ctx context.Context, limit int64) ([]GetProductsListingRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsListing, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsListingRow
	for rows.Next() {
		var i GetProductsListingRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithVatCurrency,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsWithSort = `-- name: GetProductsWithSort :many
SELECT id, serial, name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, created_at, updated_at, deleted_at
FROM tbl_product
ORDER BY
	(CASE WHEN @sort = 'sku' AND @dir = 'ASC' THEN  tbl_product.sku END) ASC,
	(CASE WHEN @sort = 'sku' AND @dir = 'DESC' THEN tbl_product.sku END) DESC,
	(CASE WHEN @sort = 'created_at' AND @dir = 'ASC' THEN tbl_product.created_at END) ASC,
	(CASE WHEN @sort = 'created_at' AND @dir = 'DESC' THEN tbl_product.created_at END) DESC
`

func (q *Queries) GetProductsWithSort(ctx context.Context) ([]TblProduct, error) {
	rows, err := q.db.QueryContext(ctx, getProductsWithSort)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TblProduct
	for rows.Next() {
		var i TblProduct
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :execlastid
UPDATE tbl_product
SET
	name = ?,
	description = ?,
	brand_id = ?,
	status = ?,
	product_specs_id = ?,
	unit_price_without_vat = ?,
	unit_price_with_vat = ?,
	unit_price_without_vat_currency = ?,
	unit_price_with_vat_currency = ?,
	created_at = ?,
	updated_at = ?,
	deleted_at = ?
WHERE id = ?
`

type UpdateProductParams struct {
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID                          int64
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProduct,
		arg.Name,
		arg.Description,
		arg.BrandID,
		arg.Status,
		arg.ProductSpecsID,
		arg.UnitPriceWithoutVat,
		arg.UnitPriceWithVat,
		arg.UnitPriceWithoutVatCurrency,
		arg.UnitPriceWithVatCurrency,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}
