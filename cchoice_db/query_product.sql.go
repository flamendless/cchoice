// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query_product.sql

package cchoice_db

import (
	"context"
	"database/sql"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO tbl_product (
	serial,
	name,
	description,
	brand,
	status,
	colours,
	sizes,
	segmentation,
	product_category_id,
	unit_price_without_vat,
	unit_price_with_vat,
	unit_price_without_vat_currency,
	unit_price_with_vat_currency,
	created_at,
	updated_at,
	deleted_at
) VALUES (
	?, ?, ?, ?,
	?, ?, ?, ?,
	?, ?, ?, ?,
	?, ?, ?, ?
) RETURNING id, serial, name, description, brand, status, product_category_id, colours, sizes, segmentation, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	Serial                      string
	Name                        string
	Description                 sql.NullString
	Brand                       string
	Status                      string
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	ProductCategoryID           sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   string
	UpdatedAt                   string
	DeletedAt                   string
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (TblProduct, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Serial,
		arg.Name,
		arg.Description,
		arg.Brand,
		arg.Status,
		arg.Colours,
		arg.Sizes,
		arg.Segmentation,
		arg.ProductCategoryID,
		arg.UnitPriceWithoutVat,
		arg.UnitPriceWithVat,
		arg.UnitPriceWithoutVatCurrency,
		arg.UnitPriceWithVatCurrency,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	var i TblProduct
	err := row.Scan(
		&i.ID,
		&i.Serial,
		&i.Name,
		&i.Description,
		&i.Brand,
		&i.Status,
		&i.ProductCategoryID,
		&i.Colours,
		&i.Sizes,
		&i.Segmentation,
		&i.UnitPriceWithoutVat,
		&i.UnitPriceWithVat,
		&i.UnitPriceWithoutVatCurrency,
		&i.UnitPriceWithVatCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT tbl_product.id, serial, name, description, brand, status, product_category_id, colours, sizes, segmentation, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, created_at, updated_at, deleted_at, tbl_product_category.id, category, subcategory
FROM tbl_product
INNER JOIN tbl_product_category ON tbl_product.product_category_id = tbl_product_category.id
WHERE tbl_product.id = ?
LIMIT 1
`

type GetProductByIDRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	Brand                       string
	Status                      string
	ProductCategoryID           sql.NullInt64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   string
	UpdatedAt                   string
	DeletedAt                   string
	ID_2                        int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
}

func (q *Queries) GetProductByID(ctx context.Context, id int64) (GetProductByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.Serial,
		&i.Name,
		&i.Description,
		&i.Brand,
		&i.Status,
		&i.ProductCategoryID,
		&i.Colours,
		&i.Sizes,
		&i.Segmentation,
		&i.UnitPriceWithoutVat,
		&i.UnitPriceWithVat,
		&i.UnitPriceWithoutVatCurrency,
		&i.UnitPriceWithVatCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ID_2,
		&i.Category,
		&i.Subcategory,
	)
	return i, err
}

const getProductByName = `-- name: GetProductByName :one
SELECT tbl_product.id, serial, name, description, brand, status, product_category_id, colours, sizes, segmentation, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, created_at, updated_at, deleted_at, tbl_product_category.id, category, subcategory
FROM tbl_product
INNER JOIN tbl_product_category ON tbl_product.product_category_id = tbl_product_category.id
WHERE tbl_product.name = ?
LIMIT 1
`

type GetProductByNameRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	Brand                       string
	Status                      string
	ProductCategoryID           sql.NullInt64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   string
	UpdatedAt                   string
	DeletedAt                   string
	ID_2                        int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
}

func (q *Queries) GetProductByName(ctx context.Context, name string) (GetProductByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByName, name)
	var i GetProductByNameRow
	err := row.Scan(
		&i.ID,
		&i.Serial,
		&i.Name,
		&i.Description,
		&i.Brand,
		&i.Status,
		&i.ProductCategoryID,
		&i.Colours,
		&i.Sizes,
		&i.Segmentation,
		&i.UnitPriceWithoutVat,
		&i.UnitPriceWithVat,
		&i.UnitPriceWithoutVatCurrency,
		&i.UnitPriceWithVatCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ID_2,
		&i.Category,
		&i.Subcategory,
	)
	return i, err
}

const getProductBySerial = `-- name: GetProductBySerial :one
SELECT tbl_product.id, serial, name, description, brand, status, product_category_id, colours, sizes, segmentation, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, created_at, updated_at, deleted_at, tbl_product_category.id, category, subcategory
FROM tbl_product
INNER JOIN tbl_product_category ON tbl_product.product_category_id = tbl_product_category.id
WHERE tbl_product.serial = ?
LIMIT 1
`

type GetProductBySerialRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	Brand                       string
	Status                      string
	ProductCategoryID           sql.NullInt64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   string
	UpdatedAt                   string
	DeletedAt                   string
	ID_2                        int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
}

func (q *Queries) GetProductBySerial(ctx context.Context, serial string) (GetProductBySerialRow, error) {
	row := q.db.QueryRowContext(ctx, getProductBySerial, serial)
	var i GetProductBySerialRow
	err := row.Scan(
		&i.ID,
		&i.Serial,
		&i.Name,
		&i.Description,
		&i.Brand,
		&i.Status,
		&i.ProductCategoryID,
		&i.Colours,
		&i.Sizes,
		&i.Segmentation,
		&i.UnitPriceWithoutVat,
		&i.UnitPriceWithVat,
		&i.UnitPriceWithoutVatCurrency,
		&i.UnitPriceWithVatCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ID_2,
		&i.Category,
		&i.Subcategory,
	)
	return i, err
}

const getProductIDBySerial = `-- name: GetProductIDBySerial :one
SELECT id
FROM tbl_product
WHERE tbl_product.serial = ?
LIMIT 1
`

func (q *Queries) GetProductIDBySerial(ctx context.Context, serial string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getProductIDBySerial, serial)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getProducts = `-- name: GetProducts :many
SELECT tbl_product.id, serial, name, description, brand, status, product_category_id, colours, sizes, segmentation, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, created_at, updated_at, deleted_at, tbl_product_category.id, category, subcategory
FROM tbl_product
INNER JOIN tbl_product_category ON tbl_product.product_category_id = tbl_product_category.id
ORDER BY created_at DESC
`

type GetProductsRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	Brand                       string
	Status                      string
	ProductCategoryID           sql.NullInt64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   string
	UpdatedAt                   string
	DeletedAt                   string
	ID_2                        int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
}

func (q *Queries) GetProducts(ctx context.Context) ([]GetProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsRow
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.Brand,
			&i.Status,
			&i.ProductCategoryID,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.Category,
			&i.Subcategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :execlastid
UPDATE tbl_product
SET
	name = ?,
	description = ?,
	brand = ?,
	status = ?,
	colours = ?,
	sizes = ?,
	segmentation = ?,
	product_category_id = ?,
	unit_price_without_vat = ?,
	unit_price_with_vat = ?,
	unit_price_without_vat_currency = ?,
	unit_price_with_vat_currency = ?,
	created_at = ?,
	updated_at = ?,
	deleted_at = ?
WHERE id = ?
`

type UpdateProductParams struct {
	Name                        string
	Description                 sql.NullString
	Brand                       string
	Status                      string
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	ProductCategoryID           sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   string
	UpdatedAt                   string
	DeletedAt                   string
	ID                          int64
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProduct,
		arg.Name,
		arg.Description,
		arg.Brand,
		arg.Status,
		arg.Colours,
		arg.Sizes,
		arg.Segmentation,
		arg.ProductCategoryID,
		arg.UnitPriceWithoutVat,
		arg.UnitPriceWithVat,
		arg.UnitPriceWithoutVatCurrency,
		arg.UnitPriceWithVatCurrency,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}
