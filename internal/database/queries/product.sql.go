// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: product.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const checkProductExistsByID = `-- name: CheckProductExistsByID :one
SELECT 1
FROM tbl_products
WHERE tbl_products.id = ?
LIMIT 1
`

func (q *Queries) CheckProductExistsByID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkProductExistsByID, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createProducts = `-- name: CreateProducts :one
INSERT INTO tbl_products (
	serial,
	name,
	description,
	brand_id,
	status,
	product_specs_id,
	unit_price_without_vat,
	unit_price_with_vat,
	unit_price_without_vat_currency,
	unit_price_with_vat_currency,
	created_at,
	updated_at,
	deleted_at
) VALUES (
	?, ?, ?, ?,
	?, ?, ?, ?,
	?, ?, ?, ?,
	?
) RETURNING id, serial, name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, created_at, updated_at, deleted_at
`

type CreateProductsParams struct {
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
}

func (q *Queries) CreateProducts(ctx context.Context, arg CreateProductsParams) (TblProduct, error) {
	row := q.db.QueryRowContext(ctx, createProducts,
		arg.Serial,
		arg.Name,
		arg.Description,
		arg.BrandID,
		arg.Status,
		arg.ProductSpecsID,
		arg.UnitPriceWithoutVat,
		arg.UnitPriceWithVat,
		arg.UnitPriceWithoutVatCurrency,
		arg.UnitPriceWithVatCurrency,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	var i TblProduct
	err := row.Scan(
		&i.ID,
		&i.Serial,
		&i.Name,
		&i.Description,
		&i.BrandID,
		&i.Status,
		&i.ProductSpecsID,
		&i.UnitPriceWithoutVat,
		&i.UnitPriceWithVat,
		&i.UnitPriceWithoutVatCurrency,
		&i.UnitPriceWithVatCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductIDBySerial = `-- name: GetProductIDBySerial :one
;

SELECT id
FROM tbl_products
WHERE tbl_products.serial = ?
LIMIT 1
`

func (q *Queries) GetProductIDBySerial(ctx context.Context, serial string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getProductIDBySerial, serial)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getProducts = `-- name: GetProducts :many
SELECT
	tbl_products.id, serial, tbl_products.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_products.created_at, tbl_products.updated_at, tbl_products.deleted_at, tbl_product_categories.id, category, subcategory, promoted_at_homepage, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, weight_unit, weight, tbl_brands.id, tbl_brands.name, tbl_brands.created_at, tbl_brands.updated_at, tbl_brands.deleted_at,
	tbl_brands.name AS brand_name
FROM tbl_products
INNER JOIN tbl_product_categories ON tbl_products.id = tbl_product_categories.product_id
INNER JOIN tbl_product_specs ON tbl_products.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brands ON tbl_brands.id = tbl_products.brand_id
ORDER BY created_at DESC
`

type GetProductsRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	PromotedAtHomepage          sql.NullBool
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	WeightUnit                  sql.NullString
	Weight                      sql.NullFloat64
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProducts(ctx context.Context) ([]GetProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsRow
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.Category,
			&i.Subcategory,
			&i.PromotedAtHomepage,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.WeightUnit,
			&i.Weight,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByFilter = `-- name: GetProductsByFilter :many
SELECT
	tbl_products.id, serial, tbl_products.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_products.created_at, tbl_products.updated_at, tbl_products.deleted_at, tbl_product_categories.id, category, subcategory, promoted_at_homepage, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, weight_unit, weight, tbl_brands.id, tbl_brands.name, tbl_brands.created_at, tbl_brands.updated_at, tbl_brands.deleted_at,
	tbl_brands.name AS brand_name
FROM tbl_products
INNER JOIN tbl_product_categories ON tbl_products.id = tbl_product_categories.product_id
INNER JOIN tbl_product_specs ON tbl_products.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brands ON tbl_brands.id = tbl_products.brand_id
WHERE
	(tbl_products.status = ?1 OR ?1 IS NULL) OR
	(tbl_brands.name = ?2 OR ?2 IS NULL)
ORDER BY tbl_products.updated_at DESC
`

type GetProductsByFilterParams struct {
	Status string
	Brand  string
}

type GetProductsByFilterRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	PromotedAtHomepage          sql.NullBool
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	WeightUnit                  sql.NullString
	Weight                      sql.NullFloat64
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsByFilter(ctx context.Context, arg GetProductsByFilterParams) ([]GetProductsByFilterRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByFilter, arg.Status, arg.Brand)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByFilterRow
	for rows.Next() {
		var i GetProductsByFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.Category,
			&i.Subcategory,
			&i.PromotedAtHomepage,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.WeightUnit,
			&i.Weight,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByID = `-- name: GetProductsByID :one
SELECT
	tbl_products.id, serial, tbl_products.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_products.created_at, tbl_products.updated_at, tbl_products.deleted_at, tbl_product_categories.id, category, subcategory, promoted_at_homepage, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, weight_unit, weight, tbl_brands.id, tbl_brands.name, tbl_brands.created_at, tbl_brands.updated_at, tbl_brands.deleted_at,
	tbl_brands.name AS brand_name
FROM tbl_products
INNER JOIN tbl_product_categories ON tbl_products.id = tbl_product_categories.product_id
INNER JOIN tbl_product_specs ON tbl_products.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brands ON tbl_brands.id = tbl_products.brand_id
WHERE tbl_products.id = ?
LIMIT 1
`

type GetProductsByIDRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	PromotedAtHomepage          sql.NullBool
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	WeightUnit                  sql.NullString
	Weight                      sql.NullFloat64
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsByID(ctx context.Context, id int64) (GetProductsByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProductsByID, id)
	var i GetProductsByIDRow
	err := row.Scan(
		&i.ID,
		&i.Serial,
		&i.Name,
		&i.Description,
		&i.BrandID,
		&i.Status,
		&i.ProductSpecsID,
		&i.UnitPriceWithoutVat,
		&i.UnitPriceWithVat,
		&i.UnitPriceWithoutVatCurrency,
		&i.UnitPriceWithVatCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ID_2,
		&i.Category,
		&i.Subcategory,
		&i.PromotedAtHomepage,
		&i.ID_3,
		&i.Colours,
		&i.Sizes,
		&i.Segmentation,
		&i.PartNumber,
		&i.Power,
		&i.Capacity,
		&i.ScopeOfSupply,
		&i.WeightUnit,
		&i.Weight,
		&i.ID_4,
		&i.Name_2,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.DeletedAt_2,
		&i.BrandName,
	)
	return i, err
}

const getProductsBySearchQuery = `-- name: GetProductsBySearchQuery :many
;


SELECT
	tbl_products.id,
	tbl_products.name,
	tbl_brands.name AS brand_name,
	COALESCE(
		tbl_product_images.thumbnail,
		'static/images/empty_96x96.webp'
	) AS thumbnail_path,
	'' as thumbnail_data
FROM tbl_products_fts
INNER JOIN tbl_products ON tbl_products.id = tbl_products_fts.rowid
INNER JOIN tbl_brands ON tbl_brands.id = tbl_products.brand_id
LEFT JOIN tbl_product_images ON tbl_product_images.product_id = tbl_products.id
WHERE
	tbl_products_fts.name MATCH ?
LIMIT ?
`

type GetProductsBySearchQueryParams struct {
	Name  string
	Limit int64
}

type GetProductsBySearchQueryRow struct {
	ID            int64
	Name          string
	BrandName     string
	ThumbnailPath string
	ThumbnailData string
}

// TODO: (Brandon) if sqlc releases PR #3498
//
//	replace WHERE with `tbl_products_fts MATCH ?`
func (q *Queries) GetProductsBySearchQuery(ctx context.Context, arg GetProductsBySearchQueryParams) ([]GetProductsBySearchQueryRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsBySearchQuery, arg.Name, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsBySearchQueryRow
	for rows.Next() {
		var i GetProductsBySearchQueryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BrandName,
			&i.ThumbnailPath,
			&i.ThumbnailData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsBySerial = `-- name: GetProductsBySerial :one
SELECT
	tbl_products.id, serial, tbl_products.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_products.created_at, tbl_products.updated_at, tbl_products.deleted_at, tbl_product_categories.id, category, subcategory, promoted_at_homepage, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, weight_unit, weight, tbl_brands.id, tbl_brands.name, tbl_brands.created_at, tbl_brands.updated_at, tbl_brands.deleted_at,
	tbl_brands.name AS brand_name
FROM tbl_products
INNER JOIN tbl_product_categories ON tbl_products.id = tbl_product_categories.product_id
INNER JOIN tbl_product_specs ON tbl_products.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brands ON tbl_brands.id = tbl_products.brand_id
WHERE tbl_products.serial = ?
LIMIT 1
`

type GetProductsBySerialRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	PromotedAtHomepage          sql.NullBool
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	WeightUnit                  sql.NullString
	Weight                      sql.NullFloat64
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsBySerial(ctx context.Context, serial string) (GetProductsBySerialRow, error) {
	row := q.db.QueryRowContext(ctx, getProductsBySerial, serial)
	var i GetProductsBySerialRow
	err := row.Scan(
		&i.ID,
		&i.Serial,
		&i.Name,
		&i.Description,
		&i.BrandID,
		&i.Status,
		&i.ProductSpecsID,
		&i.UnitPriceWithoutVat,
		&i.UnitPriceWithVat,
		&i.UnitPriceWithoutVatCurrency,
		&i.UnitPriceWithVatCurrency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ID_2,
		&i.Category,
		&i.Subcategory,
		&i.PromotedAtHomepage,
		&i.ID_3,
		&i.Colours,
		&i.Sizes,
		&i.Segmentation,
		&i.PartNumber,
		&i.Power,
		&i.Capacity,
		&i.ScopeOfSupply,
		&i.WeightUnit,
		&i.Weight,
		&i.ID_4,
		&i.Name_2,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.DeletedAt_2,
		&i.BrandName,
	)
	return i, err
}

const getProductsByStatus = `-- name: GetProductsByStatus :many
SELECT
	tbl_products.id, serial, tbl_products.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_products.created_at, tbl_products.updated_at, tbl_products.deleted_at, tbl_product_categories.id, category, subcategory, promoted_at_homepage, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, weight_unit, weight, tbl_brands.id, tbl_brands.name, tbl_brands.created_at, tbl_brands.updated_at, tbl_brands.deleted_at,
	tbl_brands.name AS brand_name
FROM tbl_products
INNER JOIN tbl_product_categories ON tbl_products.id = tbl_product_categories.product_id
INNER JOIN tbl_product_specs ON tbl_products.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brands ON tbl_brands.id = tbl_products.brand_id
WHERE tbl_products.status = ?
ORDER BY created_at DESC
`

type GetProductsByStatusRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	PromotedAtHomepage          sql.NullBool
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	WeightUnit                  sql.NullString
	Weight                      sql.NullFloat64
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsByStatus(ctx context.Context, status string) ([]GetProductsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByStatusRow
	for rows.Next() {
		var i GetProductsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.Category,
			&i.Subcategory,
			&i.PromotedAtHomepage,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.WeightUnit,
			&i.Weight,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByStatusSortByCreationDateAsc = `-- name: GetProductsByStatusSortByCreationDateAsc :many
SELECT
	tbl_products.id, serial, tbl_products.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_products.created_at, tbl_products.updated_at, tbl_products.deleted_at, tbl_product_categories.id, category, subcategory, promoted_at_homepage, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, weight_unit, weight, tbl_brands.id, tbl_brands.name, tbl_brands.created_at, tbl_brands.updated_at, tbl_brands.deleted_at,
	tbl_brands.name AS brand_name
FROM tbl_products
INNER JOIN tbl_product_categories ON tbl_products.id = tbl_product_categories.product_id
INNER JOIN tbl_product_specs ON tbl_products.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brands ON tbl_brands.id = tbl_products.brand_id
WHERE tbl_products.status = ?
ORDER BY tbl_products.created_at ASC
`

type GetProductsByStatusSortByCreationDateAscRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	PromotedAtHomepage          sql.NullBool
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	WeightUnit                  sql.NullString
	Weight                      sql.NullFloat64
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsByStatusSortByCreationDateAsc(ctx context.Context, status string) ([]GetProductsByStatusSortByCreationDateAscRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByStatusSortByCreationDateAsc, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByStatusSortByCreationDateAscRow
	for rows.Next() {
		var i GetProductsByStatusSortByCreationDateAscRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.Category,
			&i.Subcategory,
			&i.PromotedAtHomepage,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.WeightUnit,
			&i.Weight,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByStatusSortByCreationDateDesc = `-- name: GetProductsByStatusSortByCreationDateDesc :many
SELECT
	tbl_products.id, serial, tbl_products.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_products.created_at, tbl_products.updated_at, tbl_products.deleted_at, tbl_product_categories.id, category, subcategory, promoted_at_homepage, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, weight_unit, weight, tbl_brands.id, tbl_brands.name, tbl_brands.created_at, tbl_brands.updated_at, tbl_brands.deleted_at,
	tbl_brands.name AS brand_name
FROM tbl_products
INNER JOIN tbl_product_categories ON tbl_products.id = tbl_product_categories.product_id
INNER JOIN tbl_product_specs ON tbl_products.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brands ON tbl_brands.id = tbl_products.brand_id
WHERE tbl_products.status = ?
ORDER BY tbl_products.created_at DESC
`

type GetProductsByStatusSortByCreationDateDescRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	PromotedAtHomepage          sql.NullBool
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	WeightUnit                  sql.NullString
	Weight                      sql.NullFloat64
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsByStatusSortByCreationDateDesc(ctx context.Context, status string) ([]GetProductsByStatusSortByCreationDateDescRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByStatusSortByCreationDateDesc, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByStatusSortByCreationDateDescRow
	for rows.Next() {
		var i GetProductsByStatusSortByCreationDateDescRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.Category,
			&i.Subcategory,
			&i.PromotedAtHomepage,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.WeightUnit,
			&i.Weight,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByStatusSortByNameAsc = `-- name: GetProductsByStatusSortByNameAsc :many
SELECT
	tbl_products.id, serial, tbl_products.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_products.created_at, tbl_products.updated_at, tbl_products.deleted_at, tbl_product_categories.id, category, subcategory, promoted_at_homepage, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, weight_unit, weight, tbl_brands.id, tbl_brands.name, tbl_brands.created_at, tbl_brands.updated_at, tbl_brands.deleted_at,
	tbl_brands.name AS brand_name
FROM tbl_products
INNER JOIN tbl_product_categories ON tbl_products.id = tbl_product_categories.product_id
INNER JOIN tbl_product_specs ON tbl_products.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brands ON tbl_brands.id = tbl_products.brand_id
WHERE tbl_products.status = ?
ORDER BY LOWER(tbl_products.name) ASC
`

type GetProductsByStatusSortByNameAscRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	PromotedAtHomepage          sql.NullBool
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	WeightUnit                  sql.NullString
	Weight                      sql.NullFloat64
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsByStatusSortByNameAsc(ctx context.Context, status string) ([]GetProductsByStatusSortByNameAscRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByStatusSortByNameAsc, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByStatusSortByNameAscRow
	for rows.Next() {
		var i GetProductsByStatusSortByNameAscRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.Category,
			&i.Subcategory,
			&i.PromotedAtHomepage,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.WeightUnit,
			&i.Weight,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByStatusSortByNameDesc = `-- name: GetProductsByStatusSortByNameDesc :many
SELECT
	tbl_products.id, serial, tbl_products.name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, tbl_products.created_at, tbl_products.updated_at, tbl_products.deleted_at, tbl_product_categories.id, category, subcategory, promoted_at_homepage, tbl_product_specs.id, colours, sizes, segmentation, part_number, power, capacity, scope_of_supply, weight_unit, weight, tbl_brands.id, tbl_brands.name, tbl_brands.created_at, tbl_brands.updated_at, tbl_brands.deleted_at,
	tbl_brands.name AS brand_name
FROM tbl_products
INNER JOIN tbl_product_categories ON tbl_products.id = tbl_product_categories.product_id
INNER JOIN tbl_product_specs ON tbl_products.product_specs_id = tbl_product_specs.id
INNER JOIN tbl_brands ON tbl_brands.id = tbl_products.brand_id
WHERE tbl_products.status = ?
ORDER BY LOWER(tbl_products.name) DESC
`

type GetProductsByStatusSortByNameDescRow struct {
	ID                          int64
	Serial                      string
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID_2                        int64
	Category                    sql.NullString
	Subcategory                 sql.NullString
	PromotedAtHomepage          sql.NullBool
	ID_3                        int64
	Colours                     sql.NullString
	Sizes                       sql.NullString
	Segmentation                sql.NullString
	PartNumber                  sql.NullString
	Power                       sql.NullString
	Capacity                    sql.NullString
	ScopeOfSupply               sql.NullString
	WeightUnit                  sql.NullString
	Weight                      sql.NullFloat64
	ID_4                        int64
	Name_2                      string
	CreatedAt_2                 time.Time
	UpdatedAt_2                 time.Time
	DeletedAt_2                 time.Time
	BrandName                   string
}

func (q *Queries) GetProductsByStatusSortByNameDesc(ctx context.Context, status string) ([]GetProductsByStatusSortByNameDescRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByStatusSortByNameDesc, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByStatusSortByNameDescRow
	for rows.Next() {
		var i GetProductsByStatusSortByNameDescRow
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.Category,
			&i.Subcategory,
			&i.PromotedAtHomepage,
			&i.ID_3,
			&i.Colours,
			&i.Sizes,
			&i.Segmentation,
			&i.PartNumber,
			&i.Power,
			&i.Capacity,
			&i.ScopeOfSupply,
			&i.WeightUnit,
			&i.Weight,
			&i.ID_4,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsListing = `-- name: GetProductsListing :many
SELECT
	tbl_products.id,
	tbl_products.name,
	tbl_products.description,
	tbl_products.unit_price_with_vat,
	tbl_products.unit_price_with_vat_currency,
	tbl_brands.name AS brand_name
FROM tbl_products
INNER JOIN tbl_brands ON tbl_brands.id = tbl_products.brand_id
ORDER BY tbl_products.created_at DESC
LIMIT ?
`

type GetProductsListingRow struct {
	ID                       int64
	Name                     string
	Description              sql.NullString
	UnitPriceWithVat         int64
	UnitPriceWithVatCurrency string
	BrandName                string
}

func (q *Queries) GetProductsListing(ctx context.Context, limit int64) ([]GetProductsListingRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsListing, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsListingRow
	for rows.Next() {
		var i GetProductsListingRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithVatCurrency,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsWithSort = `-- name: GetProductsWithSort :many
SELECT id, serial, name, description, brand_id, status, product_specs_id, unit_price_without_vat, unit_price_with_vat, unit_price_without_vat_currency, unit_price_with_vat_currency, created_at, updated_at, deleted_at
FROM tbl_products
ORDER BY
	(CASE WHEN @sort = 'sku' AND @dir = 'ASC' THEN  tbl_products.sku END) ASC,
	(CASE WHEN @sort = 'sku' AND @dir = 'DESC' THEN tbl_products.sku END) DESC,
	(CASE WHEN @sort = 'created_at' AND @dir = 'ASC' THEN tbl_products.created_at END) ASC,
	(CASE WHEN @sort = 'created_at' AND @dir = 'DESC' THEN tbl_products.created_at END) DESC
`

func (q *Queries) GetProductsWithSort(ctx context.Context) ([]TblProduct, error) {
	rows, err := q.db.QueryContext(ctx, getProductsWithSort)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TblProduct
	for rows.Next() {
		var i TblProduct
		if err := rows.Scan(
			&i.ID,
			&i.Serial,
			&i.Name,
			&i.Description,
			&i.BrandID,
			&i.Status,
			&i.ProductSpecsID,
			&i.UnitPriceWithoutVat,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithoutVatCurrency,
			&i.UnitPriceWithVatCurrency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProducts = `-- name: UpdateProducts :execlastid
UPDATE tbl_products
SET
	name = ?,
	description = ?,
	brand_id = ?,
	status = ?,
	product_specs_id = ?,
	unit_price_without_vat = ?,
	unit_price_with_vat = ?,
	unit_price_without_vat_currency = ?,
	unit_price_with_vat_currency = ?,
	created_at = ?,
	updated_at = ?,
	deleted_at = ?
WHERE id = ?
`

type UpdateProductsParams struct {
	Name                        string
	Description                 sql.NullString
	BrandID                     int64
	Status                      string
	ProductSpecsID              sql.NullInt64
	UnitPriceWithoutVat         int64
	UnitPriceWithVat            int64
	UnitPriceWithoutVatCurrency string
	UnitPriceWithVatCurrency    string
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	DeletedAt                   time.Time
	ID                          int64
}

func (q *Queries) UpdateProducts(ctx context.Context, arg UpdateProductsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProducts,
		arg.Name,
		arg.Description,
		arg.BrandID,
		arg.Status,
		arg.ProductSpecsID,
		arg.UnitPriceWithoutVat,
		arg.UnitPriceWithVat,
		arg.UnitPriceWithoutVatCurrency,
		arg.UnitPriceWithVatCurrency,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}
