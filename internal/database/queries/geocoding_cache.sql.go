// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: geocoding_cache.sql

package queries

import (
	"context"
	"database/sql"
)

const deleteExpiredGeocodingCache = `-- name: DeleteExpiredGeocodingCache :exec
DELETE FROM tbl_geocoding_cache
WHERE expires_at IS NOT NULL
	AND expires_at <= CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredGeocodingCache(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredGeocodingCache)
	return err
}

const getGeocodingCacheByAddress = `-- name: GetGeocodingCacheByAddress :one
SELECT
	id, address, normalized_address, latitude, longitude,
	formatted_address, place_id, response_data,
	created_at, updated_at, expires_at
FROM tbl_geocoding_cache
WHERE normalized_address = ?
	AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
LIMIT 1
`

func (q *Queries) GetGeocodingCacheByAddress(ctx context.Context, normalizedAddress string) (TblGeocodingCache, error) {
	row := q.db.QueryRowContext(ctx, getGeocodingCacheByAddress, normalizedAddress)
	var i TblGeocodingCache
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.NormalizedAddress,
		&i.Latitude,
		&i.Longitude,
		&i.FormattedAddress,
		&i.PlaceID,
		&i.ResponseData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getGeocodingCacheStats = `-- name: GetGeocodingCacheStats :one
SELECT
	COUNT(*) as total_entries,
	COUNT(CASE WHEN expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP THEN 1 END) as active_entries,
	COUNT(CASE WHEN expires_at IS NOT NULL AND expires_at <= CURRENT_TIMESTAMP THEN 1 END) as expired_entries
FROM tbl_geocoding_cache
`

type GetGeocodingCacheStatsRow struct {
	TotalEntries   int64
	ActiveEntries  int64
	ExpiredEntries int64
}

func (q *Queries) GetGeocodingCacheStats(ctx context.Context) (GetGeocodingCacheStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getGeocodingCacheStats)
	var i GetGeocodingCacheStatsRow
	err := row.Scan(&i.TotalEntries, &i.ActiveEntries, &i.ExpiredEntries)
	return i, err
}

const insertGeocodingCache = `-- name: InsertGeocodingCache :one
INSERT INTO tbl_geocoding_cache (
	address,
	normalized_address,
	latitude,
	longitude,
	formatted_address,
	place_id,
	response_data,
	expires_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, address, normalized_address, latitude, longitude,
	formatted_address, place_id, response_data,
	created_at, updated_at, expires_at
`

type InsertGeocodingCacheParams struct {
	Address           string
	NormalizedAddress string
	Latitude          string
	Longitude         string
	FormattedAddress  string
	PlaceID           sql.NullString
	ResponseData      sql.NullString
	ExpiresAt         sql.NullTime
}

func (q *Queries) InsertGeocodingCache(ctx context.Context, arg InsertGeocodingCacheParams) (TblGeocodingCache, error) {
	row := q.db.QueryRowContext(ctx, insertGeocodingCache,
		arg.Address,
		arg.NormalizedAddress,
		arg.Latitude,
		arg.Longitude,
		arg.FormattedAddress,
		arg.PlaceID,
		arg.ResponseData,
		arg.ExpiresAt,
	)
	var i TblGeocodingCache
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.NormalizedAddress,
		&i.Latitude,
		&i.Longitude,
		&i.FormattedAddress,
		&i.PlaceID,
		&i.ResponseData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const updateGeocodingCache = `-- name: UpdateGeocodingCache :exec
UPDATE tbl_geocoding_cache
SET
	address = ?,
	latitude = ?,
	longitude = ?,
	formatted_address = ?,
	place_id = ?,
	response_data = ?,
	updated_at = CURRENT_TIMESTAMP,
	expires_at = ?
WHERE normalized_address = ?
`

type UpdateGeocodingCacheParams struct {
	Address           string
	Latitude          string
	Longitude         string
	FormattedAddress  string
	PlaceID           sql.NullString
	ResponseData      sql.NullString
	ExpiresAt         sql.NullTime
	NormalizedAddress string
}

func (q *Queries) UpdateGeocodingCache(ctx context.Context, arg UpdateGeocodingCacheParams) error {
	_, err := q.db.ExecContext(ctx, updateGeocodingCache,
		arg.Address,
		arg.Latitude,
		arg.Longitude,
		arg.FormattedAddress,
		arg.PlaceID,
		arg.ResponseData,
		arg.ExpiresAt,
		arg.NormalizedAddress,
	)
	return err
}

const upsertGeocodingCache = `-- name: UpsertGeocodingCache :one
INSERT INTO tbl_geocoding_cache (
	address,
	normalized_address,
	latitude,
	longitude,
	formatted_address,
	place_id,
	response_data,
	expires_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(normalized_address) DO UPDATE SET
	address = excluded.address,
	latitude = excluded.latitude,
	longitude = excluded.longitude,
	formatted_address = excluded.formatted_address,
	place_id = excluded.place_id,
	response_data = excluded.response_data,
	updated_at = CURRENT_TIMESTAMP,
	expires_at = excluded.expires_at
RETURNING id, address, normalized_address, latitude, longitude,
	formatted_address, place_id, response_data,
	created_at, updated_at, expires_at
`

type UpsertGeocodingCacheParams struct {
	Address           string
	NormalizedAddress string
	Latitude          string
	Longitude         string
	FormattedAddress  string
	PlaceID           sql.NullString
	ResponseData      sql.NullString
	ExpiresAt         sql.NullTime
}

func (q *Queries) UpsertGeocodingCache(ctx context.Context, arg UpsertGeocodingCacheParams) (TblGeocodingCache, error) {
	row := q.db.QueryRowContext(ctx, upsertGeocodingCache,
		arg.Address,
		arg.NormalizedAddress,
		arg.Latitude,
		arg.Longitude,
		arg.FormattedAddress,
		arg.PlaceID,
		arg.ResponseData,
		arg.ExpiresAt,
	)
	var i TblGeocodingCache
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.NormalizedAddress,
		&i.Latitude,
		&i.Longitude,
		&i.FormattedAddress,
		&i.PlaceID,
		&i.ResponseData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}
