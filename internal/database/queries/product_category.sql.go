// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: product_category.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const createProductCategory = `-- name: CreateProductCategory :one
INSERT INTO tbl_product_categories (
	category,
	subcategory
) VALUES (
	?, ?
) RETURNING id, category, subcategory, promoted_at_homepage
`

type CreateProductCategoryParams struct {
	Category    sql.NullString
	Subcategory sql.NullString
}

func (q *Queries) CreateProductCategory(ctx context.Context, arg CreateProductCategoryParams) (TblProductCategory, error) {
	row := q.db.QueryRowContext(ctx, createProductCategory, arg.Category, arg.Subcategory)
	var i TblProductCategory
	err := row.Scan(
		&i.ID,
		&i.Category,
		&i.Subcategory,
		&i.PromotedAtHomepage,
	)
	return i, err
}

const createProductsCategories = `-- name: CreateProductsCategories :one
INSERT INTO tbl_products_categories (
	product_id,
	category_id
) VALUES (?, ?)
ON CONFLICT (product_id, category_id) DO NOTHING
RETURNING id, category_id, product_id
`

type CreateProductsCategoriesParams struct {
	ProductID  int64
	CategoryID int64
}

func (q *Queries) CreateProductsCategories(ctx context.Context, arg CreateProductsCategoriesParams) (TblProductsCategory, error) {
	row := q.db.QueryRowContext(ctx, createProductsCategories, arg.ProductID, arg.CategoryID)
	var i TblProductsCategory
	err := row.Scan(&i.ID, &i.CategoryID, &i.ProductID)
	return i, err
}

const getProductCategoriesByPromoted = `-- name: GetProductCategoriesByPromoted :many
;

SELECT
	tbl_product_categories.id,
	tbl_product_categories.category,
	COUNT(tbl_products_categories.product_id) AS products_count
FROM tbl_product_categories
INNER JOIN tbl_products_categories ON tbl_products_categories.category_id = tbl_product_categories.id
WHERE promoted_at_homepage = ?
GROUP BY tbl_products_categories.category_id
HAVING tbl_products_categories.product_id
ORDER BY tbl_product_categories.category ASC
LIMIT ?
`

type GetProductCategoriesByPromotedParams struct {
	PromotedAtHomepage sql.NullBool
	Limit              int64
}

type GetProductCategoriesByPromotedRow struct {
	ID            int64
	Category      sql.NullString
	ProductsCount int64
}

func (q *Queries) GetProductCategoriesByPromoted(ctx context.Context, arg GetProductCategoriesByPromotedParams) ([]GetProductCategoriesByPromotedRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductCategoriesByPromoted, arg.PromotedAtHomepage, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductCategoriesByPromotedRow
	for rows.Next() {
		var i GetProductCategoriesByPromotedRow
		if err := rows.Scan(&i.ID, &i.Category, &i.ProductsCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductCategoriesForSections = `-- name: GetProductCategoriesForSections :many
;

SELECT
	tbl_product_categories.id,
	tbl_product_categories.category,
	tbl_product_categories.subcategory,
	COUNT(tbl_products_categories.product_id) AS products_count
FROM tbl_product_categories
INNER JOIN tbl_products_categories ON tbl_products_categories.category_id = tbl_product_categories.id
GROUP BY tbl_products_categories.category_id
HAVING tbl_products_categories.product_id
ORDER BY tbl_product_categories.category ASC
LIMIT 256
`

type GetProductCategoriesForSectionsRow struct {
	ID            int64
	Category      sql.NullString
	Subcategory   sql.NullString
	ProductsCount int64
}

func (q *Queries) GetProductCategoriesForSections(ctx context.Context) ([]GetProductCategoriesForSectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductCategoriesForSections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductCategoriesForSectionsRow
	for rows.Next() {
		var i GetProductCategoriesForSectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Subcategory,
			&i.ProductsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductCategoriesForSectionsPagination = `-- name: GetProductCategoriesForSectionsPagination :many
SELECT
	tbl_product_categories.id,
	tbl_product_categories.category,
	tbl_product_categories.subcategory,
	COUNT(tbl_products_categories.product_id) AS products_count
FROM tbl_product_categories
INNER JOIN tbl_products_categories ON tbl_products_categories.category_id = tbl_product_categories.id
GROUP BY tbl_products_categories.category_id
HAVING tbl_products_categories.product_id
ORDER BY tbl_product_categories.category ASC
LIMIT ?
OFFSET ?
`

type GetProductCategoriesForSectionsPaginationParams struct {
	Limit  int64
	Offset int64
}

type GetProductCategoriesForSectionsPaginationRow struct {
	ID            int64
	Category      sql.NullString
	Subcategory   sql.NullString
	ProductsCount int64
}

func (q *Queries) GetProductCategoriesForSectionsPagination(ctx context.Context, arg GetProductCategoriesForSectionsPaginationParams) ([]GetProductCategoriesForSectionsPaginationRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductCategoriesForSectionsPagination, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductCategoriesForSectionsPaginationRow
	for rows.Next() {
		var i GetProductCategoriesForSectionsPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Subcategory,
			&i.ProductsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductCategoryByCategory = `-- name: GetProductCategoryByCategory :one
SELECT id, category, subcategory, promoted_at_homepage
FROM tbl_product_categories
WHERE category = ?
LIMIT 1
`

func (q *Queries) GetProductCategoryByCategory(ctx context.Context, category sql.NullString) (TblProductCategory, error) {
	row := q.db.QueryRowContext(ctx, getProductCategoryByCategory, category)
	var i TblProductCategory
	err := row.Scan(
		&i.ID,
		&i.Category,
		&i.Subcategory,
		&i.PromotedAtHomepage,
	)
	return i, err
}

const getProductCategoryByCategoryAndSubcategory = `-- name: GetProductCategoryByCategoryAndSubcategory :one
SELECT id, category, subcategory, promoted_at_homepage
FROM tbl_product_categories
WHERE category = ? AND subcategory = ?
LIMIT 1
`

type GetProductCategoryByCategoryAndSubcategoryParams struct {
	Category    sql.NullString
	Subcategory sql.NullString
}

func (q *Queries) GetProductCategoryByCategoryAndSubcategory(ctx context.Context, arg GetProductCategoryByCategoryAndSubcategoryParams) (TblProductCategory, error) {
	row := q.db.QueryRowContext(ctx, getProductCategoryByCategoryAndSubcategory, arg.Category, arg.Subcategory)
	var i TblProductCategory
	err := row.Scan(
		&i.ID,
		&i.Category,
		&i.Subcategory,
		&i.PromotedAtHomepage,
	)
	return i, err
}

const getProductCategoryByID = `-- name: GetProductCategoryByID :one
SELECT id, category, subcategory, promoted_at_homepage
FROM tbl_product_categories
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetProductCategoryByID(ctx context.Context, id int64) (TblProductCategory, error) {
	row := q.db.QueryRowContext(ctx, getProductCategoryByID, id)
	var i TblProductCategory
	err := row.Scan(
		&i.ID,
		&i.Category,
		&i.Subcategory,
		&i.PromotedAtHomepage,
	)
	return i, err
}

const getProductsByCategoryID = `-- name: GetProductsByCategoryID :many
SELECT
	tbl_products.id,
	tbl_products.name,
	tbl_products.description,
	tbl_products.unit_price_with_vat,
	tbl_products.unit_price_with_vat_currency,
	tbl_brands.name AS brand_name,
	COALESCE(tbl_product_images.thumbnail, 'static/images/empty_96x96.webp') AS thumbnail_path,
	'' as thumbnail_data
FROM tbl_products
INNER JOIN
	tbl_brands ON tbl_brands.id = tbl_products.brand_id
INNER JOIN
	tbl_products_categories ON tbl_products_categories.product_id = tbl_products.id
LEFT JOIN
	tbl_product_images ON tbl_product_images.product_id = tbl_products.id
WHERE tbl_products_categories.category_id = ?
ORDER BY tbl_products.created_at DESC
LIMIT ?
`

type GetProductsByCategoryIDParams struct {
	CategoryID int64
	Limit      int64
}

type GetProductsByCategoryIDRow struct {
	ID                       int64
	Name                     string
	Description              sql.NullString
	UnitPriceWithVat         int64
	UnitPriceWithVatCurrency string
	BrandName                string
	ThumbnailPath            string
	ThumbnailData            string
}

func (q *Queries) GetProductsByCategoryID(ctx context.Context, arg GetProductsByCategoryIDParams) ([]GetProductsByCategoryIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByCategoryID, arg.CategoryID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByCategoryIDRow
	for rows.Next() {
		var i GetProductsByCategoryIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.UnitPriceWithVat,
			&i.UnitPriceWithVatCurrency,
			&i.BrandName,
			&i.ThumbnailPath,
			&i.ThumbnailData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsCategoriesByIDs = `-- name: GetProductsCategoriesByIDs :one
SELECT id FROM tbl_products_categories
WHERE product_id = ? AND category_id = ?
LIMIT 1
`

type GetProductsCategoriesByIDsParams struct {
	ProductID  int64
	CategoryID int64
}

func (q *Queries) GetProductsCategoriesByIDs(ctx context.Context, arg GetProductsCategoriesByIDsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getProductsCategoriesByIDs, arg.ProductID, arg.CategoryID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const setInitialPromotedProductCategories = `-- name: SetInitialPromotedProductCategories :many
UPDATE tbl_product_categories
SET promoted_at_homepage = true
WHERE
	category IN (/*SLICE:categories*/?)
RETURNING id
`

func (q *Queries) SetInitialPromotedProductCategories(ctx context.Context, categories []sql.NullString) ([]int64, error) {
	query := setInitialPromotedProductCategories
	var queryParams []interface{}
	if len(categories) > 0 {
		for _, v := range categories {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:categories*/?", strings.Repeat(",?", len(categories))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:categories*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
